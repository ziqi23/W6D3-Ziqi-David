# First Routes & Controllers

In this project you'll start playing with Rails routing.

## Learning Goals

- Be able to create routes in __config/routes.rb__
- Be able to read and understand Rails server error messages
- Know the three places that `params` come from
- Be able to nest query parameters
- Be able to write controller actions that read from and write to the database
- Know how and when to render errors

## Rails Diagram

As you work through the project, revisit this diagram at each phase and discuss
with your pair how the code you've written so far fits into the relationships
displayed here.

- ![Rails Diagram][diagram]

## Setup

To start, generate a new, blank Rails project: `rails new <project_name>
<flags>`. Don't forget to add flags to:

1. Set PostgreSQL as the database,
2. Skip setting up the project as a Git repo,
3. Skip setting up the Rails testing framework, and
4. Install a minimal build.

Grab the __.gitignore__ and __.gitattributes__ files from the starter repo at
the `Download Project` button below and copy them into the root directory of
your project.

If you prefer to use `byebug` instead of `debug` as your debugger, then replace
`debug` with `byebug` in your Gemfile. Add any other gems you want to install
(e.g., `pry-rails`).  If you make any changes to your Gemfile, run `bundle
install` to incorporate them into your project.

Next, set up your Postgres database by running `rails db:create`.

By default, Rails protects against a type of attack known as Cross-Site Request
Forgery (CSRF) by checking that non-GET requests include a valid _authenticity
token_. Don't worry about that for now. For this particular assignment, go to
__config/application.rb__. Right after the `config.load_defaults X.X` line, add:

```rb
config.action_controller.default_protect_from_forgery = false
```

Adding this line ensures that you won't need to include an authenticity token in
your `POST` request params; you'll learn what that means later. (Once you know
how to add authenticity tokens to your requests, you won't need to add this line
to your projects.)

## First routes

You're now ready to generate your first routes! Go to __config/routes.rb__ and
add the following line inside the `Rails.application.routes.draw` block:

```ruby
resources :users
```

Remember that this one line actually generates **eight routes** for you. Run
`rails routes` to see what those routes are.

Woohoo! You've set up your first eight _API endpoints_. Each route you have is
an API endpoint, which encapsulates a single action your app can take.

Look again at the left-most column, which displays the prefix for a route. Rails
uses these prefixes to generate the helper methods `<prefix>_path` and
`<prefix>_url` that you can use in your code to generate a route's path and url,
respectively. In addition to making your code more readable, these methods also
make it easier to maintain your code: if a route changes, the helper methods
will automatically generate the new path/url everywhere they appear. You will
learn more about these helper methods and their uses later.

You may notice that some of the routes seem to be missing prefixes. This is
because prefixes are based on a route's **path**, not its **verb**. All routes
with the same path will share the same prefix, meaning that a prefix does not
need to be listed more than once for any given path. So, e.g., the `index`
route--a `GET` request to `users/`--and the `create` route--a `POST` request to
`users/`--will both have the prefix `users`, even though the prefix only appears
next to the `index` route.

The ease with which Rails converts that one `resources` line into eight routes
might seem like magic, but you can do it too. Try the following:

- Comment out the `resources :users` line.
- Write out the eight routes using the route 'matching' syntax. For example:
  `get 'users/:id', to: 'users#show', as: 'user'`.

Run `rails routes` again and check that the routes you've written match the
routes generated by the `resources` helper exactly. __N.B.__: you'll probably
see some differences in the prefixes listed for your routes. Again, try to match
the `resources` output exactly. You can add a prefix to a route by using the
`as` option. For example: `get 'users/new', to: 'users#new', as: 'new_user'`.
Remember, too, that you don't need to specify a prefix more than once for any
given **path**.

What do these routes actually do? Starting your Rails server creates an instance
of a _router_. This router holds instances of the _routes_ that are defined in
your __routes.rb__ file. When a request comes in, the router tries to match a
route based on the **HTTP method** and the **URL path**. (It does this with a
_regular expression_, if you know what that is already.) The **first** matched
route then instantiates an instance of the specified controller and calls the
specified action on it.

You now have the initial routes and endpoints necessary to manage a `User`
resource. Notice, though, that your routes point to a `UsersController`, which
you don't actually have yet. Nor do you have a `User` model. You'll add the
model later. (Soon!)

## First controller

The router defines API endpoints (i.e., URL path/HTTP verb combinations) and
records which controller and action to invoke for each one. Each API endpoint
has a conventional meaning: **C**reate, **R**ead, **U**pdate, or **D**estroy a
resource. (These actions are collectively known as _CRUD_.) The
controllers and their actions are the ones actually doing the **CRUD**ing.

Create your first controller by navigating to __app/controllers__ and creating
a new file called __users_controller.rb__ containing the following skeleton:

```rb
# app/controllers/users_controller.rb

class UsersController < ApplicationController

end
```

Note that **controllers are always plural**; a controller manages requests that
pertain to a collection of _resources_. A resource is generally anything that
has a table in your database. In other words, it is anything in your application
that you will be CRUDing.

Controllers inherit from `ApplicationController`, which is a controller itself,
but one that never actually handles any requests directly.
`ApplicationController` is where you'd put helper methods that you want to share
across all controllers. If you look in
__controllers/application_controller.rb__, you will see that
`ApplicationController` inherits from `ActionController::Base`.
`ActionController::Base` provides all of the bells & whistles that Rails
controllers have; it's a lot like `ActiveRecord::Base` in that respect. All of
your controllers will inherit the features it provides since it is in the
inheritance chain:

```rb
UsersController < ApplicationController < ActionController::Base
```

Now that you have some routes and a matching controller, you have everything you
need to start handling requests.

## First launch

You have your API endpoints set up and they map to a controller that you've
created. How do you actually start taking requests?

```text
% rails server
=> Booting Puma
=> Rails 7.0.2.2 application starting in development 
=> Run `bin/rails server --help` for more startup options
Puma starting in single mode...
* Puma version: 5.6.2 (ruby 3.1.0-p0) ("Birdie's Version")
*  Min threads: 5
*  Max threads: 5
*  Environment: development
*          PID: 54618
* Listening on http://127.0.0.1:3000
* Listening on http://[::1]:3000
Use Ctrl-C to stop
```

Rails ships with a web server called Puma.

As you can see, it loads your application in _development_ mode (you'll learn
about the other two modes--_production_ and _testing_--later) and listens for
requests at `http://0.0.0.0:3000`. The last part, `:3000`, specifies the port it
is listening on. Rails defaults to port 3000 in development. The domain
`http://0.0.0.0` can be accessed from your browser simply as `http://localhost`.

In your browser, navigate to `http://localhost:3000`. Voilà! A running Rails app
with what will become a very familiar index page.

## First request

Postman should already be installed, but if not, go ahead and [install
it][postman].

Try to get a list of all your users, i.e., your _users index_. This means you
need to make a request that matches the HTTP verb and URL path that routes to
`UsersController#index`. If you run `rails routes`, you can see this is a
`GET` request to `/users`. Go ahead and make that request with Postman. (Make
sure to keep your rails server running in a terminal tab!)

Okay, that didn't work. Why?

The server log will be where you'll go to see what's going on in your
application. All the `puts` and `p` statements in your application will also go
to the server log. **Always look at the server log**; this is an essential
debugging technique. You'll see what some of the most important information is
in just a second. Here's what you see in the log:

```text
Started GET "/users" for ::1 at 2022-02-21 12:17:40 -0500
  ActiveRecord::SchemaMigration Pluck (1.3ms)  SELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC
  
AbstractController::ActionNotFound (The action 'index' could not be found for UsersController):
...
```

> Note: The `ActiveRecord::SchemaMigration` line will appear only for the first
> request to the server; if it's not there, don't worry about it!

Looks like a request came in; what's the error? It seems like it's complaining
that you don't actually have an `index` action setup in your `UsersController`.
Note that your application looked for an `index` action because the router
specified that a `GET` request to `/users` maps to `users#index`, which is the
Rails shorthand for `UsersController#index`.

Fix the problem by adding an empty `index` action to your `UsersController`:

```ruby
# app/controllers/users_controller.rb

class UsersController < ApplicationController
  def index
  end
end
```

Make the request in Postman again. It fails again, so look at the log:

```text
Started GET "/users" for ::1 at 2022-02-21 12:22:35 -0500
Processing by UsersController#index as */*
No template found for UsersController#index, rendering head :no_content
Completed 204 No Content in 0ms (ActiveRecord: 0.0ms | Allocations: 85)
...
```

> Note: If you make a `GET` request through a browser at this point--i.e., if
> you go to `http://localhost:3000/users`--you will get a `406 Not Acceptable`
> status code.

This time, it's complaining that there's a missing template. Wait a minute; you
never called `render`. Why is it trying to look for a template at all? Because
in the absence of an explicit `render` statement, your controller will by
default try to render a template with the same name as the controller action.
In this case, it was looking for a template called __index.html.erb__ in
__app/views/users__.

You're not going to deal with views and templates just yet. To get rid of this
error, just add a simple render:

```ruby
# app/controllers/users_controller.rb

class UsersController < ApplicationController
  def index
    render plain: "I'm in the index action!"
  end
end
```

Try again. It should work! Now take a look at the server log.

```text
Started GET "/users" for ::1 at 2022-02-21 12:28:24 -0500
Processing by UsersController#index as */*
  Rendering text template
  Rendered text template (Duration: 0.0ms | Allocations: 9)
Completed 200 OK in 3ms (Views: 2.8ms | Allocations: 684)
```

For every request, the server will tell you which controller and action is
processing it. In this case, it was the `UsersController`'s `index` action.

Woohoo! Your Postman request should have returned the string, "I'm in the index
action!" Victory is yours. Congratulations on successfully setting up, making,
and processing your first Rails request!

## Playing with parameters

Now you're going to focus on how data comes into your controllers from the
outside world.

The key method here is `#params`. `#params` is a method provided by
`ActionController::Base` that returns a Hash-like object of all the parameters
available. The parameters are compiled by the router and are sourced from three
places:

1. Route parameters (e.g., the `:id` from `/users/:id`)
2. A query string (i.e., the part of the URL after the `?`: `?key=value`)
3. `POST`/`PATCH`/`PUT` request data (i.e., the body of an HTTP request)

Make some `GET` requests to `/users` that include some key/value pairs in the
query string, e.g., `/users?fav_food=pizza` or `/users?admin=true`.

Check out the server log and notice that it logs how the parameters are coming
in:

```text
Started GET "/users?fav_food=pizza" for ::1 at 2022-02-21 12:32:02 -0500
Processing by UsersController#index as */*
  Parameters: {"fav_food"=>"pizza"}
  Rendering text template
  Rendered text template (Duration: 0.5ms | Allocations: 3)
Completed 200 OK in 3ms (Views: 2.4ms | Allocations: 192)
```

Now make some `POST` requests to `/users` playing around with `POST` data and
see how the parameters come in. This means putting the data in the request body
instead of in the query string. Click on the 'Body' tab in Postman and enter the
key/value pairs there. Make sure to change the HTTP verb to `POST`.

Think about what controller action you will hit when you make a `POST` request
to `/users` (check your routes again). Once again, you'll get the error that
this action is not defined on your `UsersController`:

```text
Started POST "/users" for ::1 at 2022-02-21 12:36:07 -0500
  
AbstractController::ActionNotFound (The action 'create' could not be found for UsersController):
...
```

Go ahead and add that method to the controller. Again, if you don't explicitly
render or redirect, Rails is going to try to render the template with the same
name; it's going to look for __create.html.erb__ in your __app/views/users__
folder, which you don't have. To prevent this, you need to explicitly render
something simple back. In this case, render the params that came in with the
request. You can `render json:`, which will automatically call `to_json` on the
object you're rendering (here, your `params`) and package it up for you so that
it can be sent back with the response:

```ruby
# app/controllers/users_controller.rb

class UsersController < ApplicationController
  def create
    render json: params
  end
end
```

Try making the request in Postman again. You should see the right response now!

```json
{
  "fav_food": "pizza",
  "controller": "users",
  "action": "create"
}
```

Okay, you've seen params come from the query string and the request body. Now
you will send them from the third and final place they can come from: the route
params.

When you include `show`, `delete`, and `update` routes in your `resources`,
Rails constructs _Uniform Resource Identifier (URI) patterns_ for these that
include a _dynamic segment_ matcher. A URL path is split into _segments_ by
`/`s. A _dynamic segment_ is any segment of the URI pattern that begins with a
`:`. If you look at your routes, you can see these wherever the URI pattern is
`users/:id(format)`. The `:id` indicates that the router will match anything put
into that segment of the URL and save it in `params` under the key `id`.

Try making a `GET` request to `/users/:id`. In Postman, this means setting
the URL to something like '/users/2', where 2 is the `id` of the `User` you want
to see.

Once again, you get the same error. You are matching the `UsersController#show`
route, but you don't have that action defined on the controller. Go ahead and
add it, and once again `render json: params`. Now try the request again. You see
the `:id` matcher saved the `2` from your URL in the params!

```json
{
  "controller": "users",
  "action": "show",
  "id": "2"
}
```

> Note: If you forget to change your verb back to `GET` in Postman, you will get
> an error because there is no `POST` route with the URI pattern `users/:id`:

```text
Started POST "/users/2" for ::1 at 2022-02-22 11:53:43 -0500
  
ActionController::RoutingError (No route matches [POST] "/users/2"):
```

> Just change the verb to `GET` and you should be good to go!

### Nesting parameters

Notice how all of your parameters come in at the top level of `params`. What if
you want to structure it a bit differently so that certain parameters come in
nested under others (i.e., a hash within a hash), like so:

```json
{
  "id": 5,
  "some_category": {
    "a_key": "another value",
    "a_second_key": "yet another value",
    "inner_inner_hash": {
      "key": "value"
    }
  },
  "something_else": "aaahhhhh"
}
```

Here's how you would accomplish this:

```html
<!-- in Postman's "Body" tab -->
some_category[a_key]: another value
some_category[a_second_key]: yet another value
some_category[inner_inner_hash][key]: value
something_else: aaahhhhh

<!-- in the query string -->
'/users?some_category[a_key]=another+value&some_category[a_second_key]=yet+another+value&some_category[inner_inner_hash][key]=value&something_else=aaahhhhh'
```

If you follow this bracket notation, Rails will nest the parameters for you. The
rule is that the keys in brackets get nested deeper in `params`.

Try it out a few times with both `GET` and `POST` requests. Make sure you're
looking at the parameters that come in with the request, either through your
controller action's rendering them back as JSON to Postman or in the server
logs.

## Using models

By this point you know how to set up routes, how to set up matching controller
actions, how to send and process incoming data through parameters, and how to
render something back to the requester. Now you will mix in some models.

Build a `User` model with name and email. Write a migration to add columns for
`name` and `email` with `null: false` constraints. Migrate your database and add
validations for presence of name and email. Add a couple users through the
console. (Make sure you save them to the database!)

In your `UsersController#index`, fetch all the users from the database and
render them as JSON. Remember that when you hand `render json:` anything, it
automatically calls `to_json` on it for you.

Make the request in Postman and make sure you're getting the right JSON back.
Check your server log and note that the SQL that ran is logged there for you.
All SQL queries your app makes will show up in the server log - yet another
useful piece of information that the log contains.

```text
Started GET "/users" for ::1 at 2022-02-22 14:19:58 -0500
Processing by UsersController#index as */*
  User Load (0.3ms)  SELECT "users".* FROM "users"
  ↳ app/controllers/users_controller.rb:6:in `index'
Completed 200 OK in 5ms (Views: 4.6ms | ActiveRecord: 0.3ms | Allocations: 992)
```

Congrats! Applications, and especially web APIs, are all about connecting data
in your database with the outside world. You've just done that.

### Creating a `User` through the API

Now you can provide a way to create a new user through the API. Below is a start
for a `create` action. Note that you are not using an instance variable for
`user`: you will see why instance variables are very useful when you start
working with views, but they aren't strictly necessary for the controller to
work with models or to interact with the database.

```ruby
# app/controller/users_controller.rb

def create
  user = User.new(params.require(:user).permit(:user_attributes_here))
  # replace the `user_attributes_here` with the actual attribute keys
  user.save!
  render json: user
end
```

Go ahead and make a `POST` request to create a new user with Postman. Make sure
to nest your params correctly! By calling `.require(:user)` on `params`, the
`UsersController#create` method is requiring that all user params be nested
under the key of `user` in `params`.

This _namespacing_ of all user params under `user` leverages mass assignment to
set all the uploaded attributes at once. This is an extremely common Rails
pattern: pretty much every time your request body includes attributes for
creating or updating a resource, you will nest them within an inner hash to use
for mass assignment.

### Handling submission errors

What if the user doesn't upload valid parameters for a new `User`? Try making
the same request as before but with no `email` param, only a `name`.

This doesn't upload the required email attribute. The controller will create a
`User` object, but when it calls `save!` the validation will fail and an error
will be raised.

To inform the user of what went wrong, it is typical to send back error
messages. Modify your controller code to send back the errors as JSON in
the event of a failure:

```ruby
# app/controller/users_controller.rb

def create
  user = User.new(params.require(:user).permit(:name, :email))
  if user.save
    render json: user
  else
    render json: user.errors.full_messages, status: :unprocessable_entity
  end
end
```

Note that if the save of the user fails, you send the errors back to the client.
You also set the status code. By default, the status code will be 200 (OK); if
something has gone wrong, use a non-200 code to indicate this. In this case, you
should return a status code of 422. Rails gives us names for these various
status codes so that the code is a bit more semantic. Here is a list of the
[Rails status code names][rails-codes].

Make the request again. You should see the error message displayed in Postman.

Now build some other controller actions:

- `show`
- `update` (you'll want to use `ActiveRecord::Base#update`)
- `destroy`

Think about what each action's purpose is, what data is coming in (params), what
your controller needs to do with the model, and what it ultimately should
render. Test each of them out in Postman as you go!

While you're at it, try refactoring the `params[...].permit(...)` stuff into its
own (private) method. If you need an example, check out the controllers
reading.

## What you've learned

In this project, you learned how to create the RESTful routes, both by using the
`resources` helper and by writing out the route-matching syntax. You then built
out the corresponding actions in your controller, using requests from Postman
and the browser to test your code. You also learned about the three different
ways that parameters can be passed into your application (i.e., query string,
body, and route). Finally, you learned how to nest your params under an
appropriate namespace, how to use that namespace in mass assignments, and how to
respond to a request by rendering data or errors in JSON.  

[diagram]: https://assets.aaonline.io/fullstack/rails/assets/rails_diagram.png
[postman]: https://www.getpostman.com/
[rails-codes]: http://guides.rubyonrails.org/layouts_and_rendering.html#the-status-option